// Code generated by ogen, DO NOT EDIT.

package exasdk

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AnswerCitation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerCitation) encodeFields(e *jx.Encoder) {
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
	{
		if s.Favicon.Set {
			e.FieldStart("favicon")
			s.Favicon.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Image.Set {
			e.FieldStart("image")
			s.Image.Encode(e)
		}
	}
	{
		if s.PublishedDate.Set {
			e.FieldStart("publishedDate")
			s.PublishedDate.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnswerCitation = [8]string{
	0: "author",
	1: "favicon",
	2: "id",
	3: "image",
	4: "publishedDate",
	5: "text",
	6: "title",
	7: "url",
}

// Decode decodes AnswerCitation from json.
func (s *AnswerCitation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerCitation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "favicon":
			if err := func() error {
				s.Favicon.Reset()
				if err := s.Favicon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favicon\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "image":
			if err := func() error {
				s.Image.Reset()
				if err := s.Image.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "publishedDate":
			if err := func() error {
				s.PublishedDate.Reset()
				if err := s.PublishedDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publishedDate\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerCitation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerCitation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerCitation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnswerReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("query")
		e.Str(s.Query)
	}
	{
		if s.Stream.Set {
			e.FieldStart("stream")
			s.Stream.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnswerReq = [3]string{
	0: "query",
	1: "stream",
	2: "text",
}

// Decode decodes AnswerReq from json.
func (s *AnswerReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "query":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Query = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "stream":
			if err := func() error {
				s.Stream.Reset()
				if err := s.Stream.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stream\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAnswerReq) {
					name = jsonFieldsNameOfAnswerReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AnswerResponseApplicationJSON) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AnswerResponseApplicationJSON) encodeFields(e *jx.Encoder) {
	{
		if s.Answer.Set {
			e.FieldStart("answer")
			s.Answer.Encode(e)
		}
	}
	{
		if s.Citations != nil {
			e.FieldStart("citations")
			e.ArrStart()
			for _, elem := range s.Citations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CostDollars.Set {
			e.FieldStart("costDollars")
			s.CostDollars.Encode(e)
		}
	}
}

var jsonFieldsNameOfAnswerResponseApplicationJSON = [3]string{
	0: "answer",
	1: "citations",
	2: "costDollars",
}

// Decode decodes AnswerResponseApplicationJSON from json.
func (s *AnswerResponseApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AnswerResponseApplicationJSON to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "answer":
			if err := func() error {
				s.Answer.Reset()
				if err := s.Answer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"answer\"")
			}
		case "citations":
			if err := func() error {
				s.Citations = make([]AnswerCitation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AnswerCitation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Citations = append(s.Citations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"citations\"")
			}
		case "costDollars":
			if err := func() error {
				s.CostDollars.Reset()
				if err := s.CostDollars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"costDollars\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AnswerResponseApplicationJSON")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AnswerResponseApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AnswerResponseApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentsRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentsRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.Extras.Set {
			e.FieldStart("extras")
			s.Extras.Encode(e)
		}
	}
	{
		if s.Highlights.Set {
			e.FieldStart("highlights")
			s.Highlights.Encode(e)
		}
	}
	{
		if s.Livecrawl.Set {
			e.FieldStart("livecrawl")
			s.Livecrawl.Encode(e)
		}
	}
	{
		if s.LivecrawlTimeout.Set {
			e.FieldStart("livecrawlTimeout")
			s.LivecrawlTimeout.Encode(e)
		}
	}
	{
		if s.SubpageTarget.Set {
			e.FieldStart("subpageTarget")
			s.SubpageTarget.Encode(e)
		}
	}
	{
		if s.Subpages.Set {
			e.FieldStart("subpages")
			s.Subpages.Encode(e)
		}
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
}

var jsonFieldsNameOfContentsRequest = [9]string{
	0: "context",
	1: "extras",
	2: "highlights",
	3: "livecrawl",
	4: "livecrawlTimeout",
	5: "subpageTarget",
	6: "subpages",
	7: "summary",
	8: "text",
}

// Decode decodes ContentsRequest from json.
func (s *ContentsRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsRequest to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "extras":
			if err := func() error {
				s.Extras.Reset()
				if err := s.Extras.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extras\"")
			}
		case "highlights":
			if err := func() error {
				s.Highlights.Reset()
				if err := s.Highlights.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlights\"")
			}
		case "livecrawl":
			if err := func() error {
				s.Livecrawl.Reset()
				if err := s.Livecrawl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"livecrawl\"")
			}
		case "livecrawlTimeout":
			if err := func() error {
				s.LivecrawlTimeout.Reset()
				if err := s.LivecrawlTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"livecrawlTimeout\"")
			}
		case "subpageTarget":
			if err := func() error {
				s.SubpageTarget.Reset()
				if err := s.SubpageTarget.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subpageTarget\"")
			}
		case "subpages":
			if err := func() error {
				s.Subpages.Reset()
				if err := s.Subpages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subpages\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentsRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsRequestContext as json.
func (s ContentsRequestContext) Encode(e *jx.Encoder) {
	switch s.Type {
	case BoolContentsRequestContext:
		e.Bool(s.Bool)
	case ContentsRequestContext1ContentsRequestContext:
		s.ContentsRequestContext1.Encode(e)
	}
}

// Decode decodes ContentsRequestContext from json.
func (s *ContentsRequestContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsRequestContext to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolContentsRequestContext
	case jx.Object:
		if err := s.ContentsRequestContext1.Decode(d); err != nil {
			return err
		}
		s.Type = ContentsRequestContext1ContentsRequestContext
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ContentsRequestContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsRequestContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentsRequestContext1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentsRequestContext1) encodeFields(e *jx.Encoder) {
	{
		if s.MaxCharacters.Set {
			e.FieldStart("maxCharacters")
			s.MaxCharacters.Encode(e)
		}
	}
}

var jsonFieldsNameOfContentsRequestContext1 = [1]string{
	0: "maxCharacters",
}

// Decode decodes ContentsRequestContext1 from json.
func (s *ContentsRequestContext1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsRequestContext1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxCharacters":
			if err := func() error {
				s.MaxCharacters.Reset()
				if err := s.MaxCharacters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxCharacters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentsRequestContext1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentsRequestContext1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsRequestContext1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentsRequestExtras) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentsRequestExtras) encodeFields(e *jx.Encoder) {
	{
		if s.ImageLinks.Set {
			e.FieldStart("imageLinks")
			s.ImageLinks.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
}

var jsonFieldsNameOfContentsRequestExtras = [2]string{
	0: "imageLinks",
	1: "links",
}

// Decode decodes ContentsRequestExtras from json.
func (s *ContentsRequestExtras) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsRequestExtras to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "imageLinks":
			if err := func() error {
				s.ImageLinks.Reset()
				if err := s.ImageLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageLinks\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentsRequestExtras")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentsRequestExtras) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsRequestExtras) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentsRequestHighlights) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentsRequestHighlights) encodeFields(e *jx.Encoder) {
	{
		if s.HighlightsPerUrl.Set {
			e.FieldStart("highlightsPerUrl")
			s.HighlightsPerUrl.Encode(e)
		}
	}
	{
		if s.NumSentences.Set {
			e.FieldStart("numSentences")
			s.NumSentences.Encode(e)
		}
	}
	{
		if s.Query.Set {
			e.FieldStart("query")
			s.Query.Encode(e)
		}
	}
}

var jsonFieldsNameOfContentsRequestHighlights = [3]string{
	0: "highlightsPerUrl",
	1: "numSentences",
	2: "query",
}

// Decode decodes ContentsRequestHighlights from json.
func (s *ContentsRequestHighlights) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsRequestHighlights to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "highlightsPerUrl":
			if err := func() error {
				s.HighlightsPerUrl.Reset()
				if err := s.HighlightsPerUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlightsPerUrl\"")
			}
		case "numSentences":
			if err := func() error {
				s.NumSentences.Reset()
				if err := s.NumSentences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numSentences\"")
			}
		case "query":
			if err := func() error {
				s.Query.Reset()
				if err := s.Query.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentsRequestHighlights")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentsRequestHighlights) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsRequestHighlights) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsRequestLivecrawl as json.
func (s ContentsRequestLivecrawl) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ContentsRequestLivecrawl from json.
func (s *ContentsRequestLivecrawl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsRequestLivecrawl to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ContentsRequestLivecrawl(v) {
	case ContentsRequestLivecrawlNever:
		*s = ContentsRequestLivecrawlNever
	case ContentsRequestLivecrawlFallback:
		*s = ContentsRequestLivecrawlFallback
	case ContentsRequestLivecrawlAlways:
		*s = ContentsRequestLivecrawlAlways
	case ContentsRequestLivecrawlPreferred:
		*s = ContentsRequestLivecrawlPreferred
	default:
		*s = ContentsRequestLivecrawl(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ContentsRequestLivecrawl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsRequestLivecrawl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsRequestSubpageTarget as json.
func (s ContentsRequestSubpageTarget) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringContentsRequestSubpageTarget:
		e.Str(s.String)
	case StringArrayContentsRequestSubpageTarget:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes ContentsRequestSubpageTarget from json.
func (s *ContentsRequestSubpageTarget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsRequestSubpageTarget to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayContentsRequestSubpageTarget
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringContentsRequestSubpageTarget
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ContentsRequestSubpageTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsRequestSubpageTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentsRequestSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentsRequestSummary) encodeFields(e *jx.Encoder) {
	{
		if s.Query.Set {
			e.FieldStart("query")
			s.Query.Encode(e)
		}
	}
	{
		if s.Schema != nil {
			e.FieldStart("schema")
			s.Schema.Encode(e)
		}
	}
}

var jsonFieldsNameOfContentsRequestSummary = [2]string{
	0: "query",
	1: "schema",
}

// Decode decodes ContentsRequestSummary from json.
func (s *ContentsRequestSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsRequestSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "query":
			if err := func() error {
				s.Query.Reset()
				if err := s.Query.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "schema":
			if err := func() error {
				s.Schema = nil
				var elem ContentsRequestSummarySchema
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Schema = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentsRequestSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentsRequestSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsRequestSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentsRequestSummarySchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentsRequestSummarySchema) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfContentsRequestSummarySchema = [0]string{}

// Decode decodes ContentsRequestSummarySchema from json.
func (s *ContentsRequestSummarySchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsRequestSummarySchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ContentsRequestSummarySchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentsRequestSummarySchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsRequestSummarySchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsRequestText as json.
func (s ContentsRequestText) Encode(e *jx.Encoder) {
	switch s.Type {
	case BoolContentsRequestText:
		e.Bool(s.Bool)
	case ContentsRequestText1ContentsRequestText:
		s.ContentsRequestText1.Encode(e)
	}
}

// Decode decodes ContentsRequestText from json.
func (s *ContentsRequestText) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsRequestText to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolContentsRequestText
	case jx.Object:
		if err := s.ContentsRequestText1.Decode(d); err != nil {
			return err
		}
		s.Type = ContentsRequestText1ContentsRequestText
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ContentsRequestText) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsRequestText) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentsRequestText1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentsRequestText1) encodeFields(e *jx.Encoder) {
	{
		if s.IncludeHtmlTags.Set {
			e.FieldStart("includeHtmlTags")
			s.IncludeHtmlTags.Encode(e)
		}
	}
	{
		if s.MaxCharacters.Set {
			e.FieldStart("maxCharacters")
			s.MaxCharacters.Encode(e)
		}
	}
}

var jsonFieldsNameOfContentsRequestText1 = [2]string{
	0: "includeHtmlTags",
	1: "maxCharacters",
}

// Decode decodes ContentsRequestText1 from json.
func (s *ContentsRequestText1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsRequestText1 to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "includeHtmlTags":
			if err := func() error {
				s.IncludeHtmlTags.Reset()
				if err := s.IncludeHtmlTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeHtmlTags\"")
			}
		case "maxCharacters":
			if err := func() error {
				s.MaxCharacters.Reset()
				if err := s.MaxCharacters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxCharacters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentsRequestText1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentsRequestText1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsRequestText1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.CostDollars.Set {
			e.FieldStart("costDollars")
			s.CostDollars.Encode(e)
		}
	}
	{
		if s.RequestId.Set {
			e.FieldStart("requestId")
			s.RequestId.Encode(e)
		}
	}
	{
		if s.Results != nil {
			e.FieldStart("results")
			e.ArrStart()
			for _, elem := range s.Results {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Statuses != nil {
			e.FieldStart("statuses")
			e.ArrStart()
			for _, elem := range s.Statuses {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfContentsResponse = [5]string{
	0: "context",
	1: "costDollars",
	2: "requestId",
	3: "results",
	4: "statuses",
}

// Decode decodes ContentsResponse from json.
func (s *ContentsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "costDollars":
			if err := func() error {
				s.CostDollars.Reset()
				if err := s.CostDollars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"costDollars\"")
			}
		case "requestId":
			if err := func() error {
				s.RequestId.Reset()
				if err := s.RequestId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestId\"")
			}
		case "results":
			if err := func() error {
				s.Results = make([]ResultWithContent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResultWithContent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "statuses":
			if err := func() error {
				s.Statuses = make([]ContentsResponseStatusesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ContentsResponseStatusesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Statuses = append(s.Statuses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentsResponseStatusesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentsResponseStatusesItem) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfContentsResponseStatusesItem = [3]string{
	0: "error",
	1: "id",
	2: "status",
}

// Decode decodes ContentsResponseStatusesItem from json.
func (s *ContentsResponseStatusesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsResponseStatusesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentsResponseStatusesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentsResponseStatusesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsResponseStatusesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContentsResponseStatusesItemError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContentsResponseStatusesItemError) encodeFields(e *jx.Encoder) {
	{
		if s.HttpStatusCode.Set {
			e.FieldStart("httpStatusCode")
			s.HttpStatusCode.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
}

var jsonFieldsNameOfContentsResponseStatusesItemError = [2]string{
	0: "httpStatusCode",
	1: "tag",
}

// Decode decodes ContentsResponseStatusesItemError from json.
func (s *ContentsResponseStatusesItemError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsResponseStatusesItemError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "httpStatusCode":
			if err := func() error {
				s.HttpStatusCode.Reset()
				if err := s.HttpStatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpStatusCode\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContentsResponseStatusesItemError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContentsResponseStatusesItemError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsResponseStatusesItemError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsResponseStatusesItemErrorTag as json.
func (s ContentsResponseStatusesItemErrorTag) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ContentsResponseStatusesItemErrorTag from json.
func (s *ContentsResponseStatusesItemErrorTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsResponseStatusesItemErrorTag to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ContentsResponseStatusesItemErrorTag(v) {
	case ContentsResponseStatusesItemErrorTagCRAWLNOTFOUND:
		*s = ContentsResponseStatusesItemErrorTagCRAWLNOTFOUND
	case ContentsResponseStatusesItemErrorTagCRAWLTIMEOUT:
		*s = ContentsResponseStatusesItemErrorTagCRAWLTIMEOUT
	case ContentsResponseStatusesItemErrorTagCRAWLLIVECRAWLTIMEOUT:
		*s = ContentsResponseStatusesItemErrorTagCRAWLLIVECRAWLTIMEOUT
	case ContentsResponseStatusesItemErrorTagSOURCENOTAVAILABLE:
		*s = ContentsResponseStatusesItemErrorTagSOURCENOTAVAILABLE
	case ContentsResponseStatusesItemErrorTagCRAWLUNKNOWNERROR:
		*s = ContentsResponseStatusesItemErrorTagCRAWLUNKNOWNERROR
	default:
		*s = ContentsResponseStatusesItemErrorTag(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ContentsResponseStatusesItemErrorTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsResponseStatusesItemErrorTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsResponseStatusesItemStatus as json.
func (s ContentsResponseStatusesItemStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ContentsResponseStatusesItemStatus from json.
func (s *ContentsResponseStatusesItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContentsResponseStatusesItemStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ContentsResponseStatusesItemStatus(v) {
	case ContentsResponseStatusesItemStatusSuccess:
		*s = ContentsResponseStatusesItemStatusSuccess
	case ContentsResponseStatusesItemStatusError:
		*s = ContentsResponseStatusesItemStatusError
	default:
		*s = ContentsResponseStatusesItemStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ContentsResponseStatusesItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContentsResponseStatusesItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CostDollars) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CostDollars) encodeFields(e *jx.Encoder) {
	{
		if s.BreakDown != nil {
			e.FieldStart("breakDown")
			e.ArrStart()
			for _, elem := range s.BreakDown {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.PerPagePrices.Set {
			e.FieldStart("perPagePrices")
			s.PerPagePrices.Encode(e)
		}
	}
	{
		if s.PerRequestPrices.Set {
			e.FieldStart("perRequestPrices")
			s.PerRequestPrices.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
}

var jsonFieldsNameOfCostDollars = [4]string{
	0: "breakDown",
	1: "perPagePrices",
	2: "perRequestPrices",
	3: "total",
}

// Decode decodes CostDollars from json.
func (s *CostDollars) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CostDollars to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "breakDown":
			if err := func() error {
				s.BreakDown = make([]CostDollarsBreakDownItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CostDollarsBreakDownItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BreakDown = append(s.BreakDown, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"breakDown\"")
			}
		case "perPagePrices":
			if err := func() error {
				s.PerPagePrices.Reset()
				if err := s.PerPagePrices.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perPagePrices\"")
			}
		case "perRequestPrices":
			if err := func() error {
				s.PerRequestPrices.Reset()
				if err := s.PerRequestPrices.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"perRequestPrices\"")
			}
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CostDollars")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CostDollars) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CostDollars) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CostDollarsBreakDownItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CostDollarsBreakDownItem) encodeFields(e *jx.Encoder) {
	{
		if s.Breakdown.Set {
			e.FieldStart("breakdown")
			s.Breakdown.Encode(e)
		}
	}
	{
		if s.Contents.Set {
			e.FieldStart("contents")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Search.Set {
			e.FieldStart("search")
			s.Search.Encode(e)
		}
	}
}

var jsonFieldsNameOfCostDollarsBreakDownItem = [3]string{
	0: "breakdown",
	1: "contents",
	2: "search",
}

// Decode decodes CostDollarsBreakDownItem from json.
func (s *CostDollarsBreakDownItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CostDollarsBreakDownItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "breakdown":
			if err := func() error {
				s.Breakdown.Reset()
				if err := s.Breakdown.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"breakdown\"")
			}
		case "contents":
			if err := func() error {
				s.Contents.Reset()
				if err := s.Contents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents\"")
			}
		case "search":
			if err := func() error {
				s.Search.Reset()
				if err := s.Search.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"search\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CostDollarsBreakDownItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CostDollarsBreakDownItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CostDollarsBreakDownItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CostDollarsBreakDownItemBreakdown) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CostDollarsBreakDownItemBreakdown) encodeFields(e *jx.Encoder) {
	{
		if s.ContentHighlight.Set {
			e.FieldStart("contentHighlight")
			s.ContentHighlight.Encode(e)
		}
	}
	{
		if s.ContentSummary.Set {
			e.FieldStart("contentSummary")
			s.ContentSummary.Encode(e)
		}
	}
	{
		if s.ContentText.Set {
			e.FieldStart("contentText")
			s.ContentText.Encode(e)
		}
	}
	{
		if s.DeepSearch.Set {
			e.FieldStart("deepSearch")
			s.DeepSearch.Encode(e)
		}
	}
	{
		if s.NeuralSearch.Set {
			e.FieldStart("neuralSearch")
			s.NeuralSearch.Encode(e)
		}
	}
}

var jsonFieldsNameOfCostDollarsBreakDownItemBreakdown = [5]string{
	0: "contentHighlight",
	1: "contentSummary",
	2: "contentText",
	3: "deepSearch",
	4: "neuralSearch",
}

// Decode decodes CostDollarsBreakDownItemBreakdown from json.
func (s *CostDollarsBreakDownItemBreakdown) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CostDollarsBreakDownItemBreakdown to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contentHighlight":
			if err := func() error {
				s.ContentHighlight.Reset()
				if err := s.ContentHighlight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contentHighlight\"")
			}
		case "contentSummary":
			if err := func() error {
				s.ContentSummary.Reset()
				if err := s.ContentSummary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contentSummary\"")
			}
		case "contentText":
			if err := func() error {
				s.ContentText.Reset()
				if err := s.ContentText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contentText\"")
			}
		case "deepSearch":
			if err := func() error {
				s.DeepSearch.Reset()
				if err := s.DeepSearch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deepSearch\"")
			}
		case "neuralSearch":
			if err := func() error {
				s.NeuralSearch.Reset()
				if err := s.NeuralSearch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neuralSearch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CostDollarsBreakDownItemBreakdown")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CostDollarsBreakDownItemBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CostDollarsBreakDownItemBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CostDollarsPerPagePrices) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CostDollarsPerPagePrices) encodeFields(e *jx.Encoder) {
	{
		if s.ContentHighlight.Set {
			e.FieldStart("contentHighlight")
			s.ContentHighlight.Encode(e)
		}
	}
	{
		if s.ContentSummary.Set {
			e.FieldStart("contentSummary")
			s.ContentSummary.Encode(e)
		}
	}
	{
		if s.ContentText.Set {
			e.FieldStart("contentText")
			s.ContentText.Encode(e)
		}
	}
}

var jsonFieldsNameOfCostDollarsPerPagePrices = [3]string{
	0: "contentHighlight",
	1: "contentSummary",
	2: "contentText",
}

// Decode decodes CostDollarsPerPagePrices from json.
func (s *CostDollarsPerPagePrices) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CostDollarsPerPagePrices to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contentHighlight":
			if err := func() error {
				s.ContentHighlight.Reset()
				if err := s.ContentHighlight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contentHighlight\"")
			}
		case "contentSummary":
			if err := func() error {
				s.ContentSummary.Reset()
				if err := s.ContentSummary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contentSummary\"")
			}
		case "contentText":
			if err := func() error {
				s.ContentText.Reset()
				if err := s.ContentText.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contentText\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CostDollarsPerPagePrices")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CostDollarsPerPagePrices) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CostDollarsPerPagePrices) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CostDollarsPerRequestPrices) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CostDollarsPerRequestPrices) encodeFields(e *jx.Encoder) {
	{
		if s.DeepSearch125Results.Set {
			e.FieldStart("deepSearch_1_25_results")
			s.DeepSearch125Results.Encode(e)
		}
	}
	{
		if s.DeepSearch26100Results.Set {
			e.FieldStart("deepSearch_26_100_results")
			s.DeepSearch26100Results.Encode(e)
		}
	}
	{
		if s.NeuralSearch125Results.Set {
			e.FieldStart("neuralSearch_1_25_results")
			s.NeuralSearch125Results.Encode(e)
		}
	}
	{
		if s.NeuralSearch26100Results.Set {
			e.FieldStart("neuralSearch_26_100_results")
			s.NeuralSearch26100Results.Encode(e)
		}
	}
	{
		if s.NeuralSearch100PlusResults.Set {
			e.FieldStart("neuralSearch_100_plus_results")
			s.NeuralSearch100PlusResults.Encode(e)
		}
	}
}

var jsonFieldsNameOfCostDollarsPerRequestPrices = [5]string{
	0: "deepSearch_1_25_results",
	1: "deepSearch_26_100_results",
	2: "neuralSearch_1_25_results",
	3: "neuralSearch_26_100_results",
	4: "neuralSearch_100_plus_results",
}

// Decode decodes CostDollarsPerRequestPrices from json.
func (s *CostDollarsPerRequestPrices) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CostDollarsPerRequestPrices to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "deepSearch_1_25_results":
			if err := func() error {
				s.DeepSearch125Results.Reset()
				if err := s.DeepSearch125Results.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deepSearch_1_25_results\"")
			}
		case "deepSearch_26_100_results":
			if err := func() error {
				s.DeepSearch26100Results.Reset()
				if err := s.DeepSearch26100Results.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deepSearch_26_100_results\"")
			}
		case "neuralSearch_1_25_results":
			if err := func() error {
				s.NeuralSearch125Results.Reset()
				if err := s.NeuralSearch125Results.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neuralSearch_1_25_results\"")
			}
		case "neuralSearch_26_100_results":
			if err := func() error {
				s.NeuralSearch26100Results.Reset()
				if err := s.NeuralSearch26100Results.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neuralSearch_26_100_results\"")
			}
		case "neuralSearch_100_plus_results":
			if err := func() error {
				s.NeuralSearch100PlusResults.Reset()
				if err := s.NeuralSearch100PlusResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neuralSearch_100_plus_results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CostDollarsPerRequestPrices")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CostDollarsPerRequestPrices) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CostDollarsPerRequestPrices) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindSimilarReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindSimilarReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		if s.Contents.Set {
			e.FieldStart("contents")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.EndCrawlDate.Set {
			e.FieldStart("endCrawlDate")
			s.EndCrawlDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EndPublishedDate.Set {
			e.FieldStart("endPublishedDate")
			s.EndPublishedDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ExcludeDomains != nil {
			e.FieldStart("excludeDomains")
			e.ArrStart()
			for _, elem := range s.ExcludeDomains {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExcludeText != nil {
			e.FieldStart("excludeText")
			e.ArrStart()
			for _, elem := range s.ExcludeText {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IncludeDomains != nil {
			e.FieldStart("includeDomains")
			e.ArrStart()
			for _, elem := range s.IncludeDomains {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IncludeText != nil {
			e.FieldStart("includeText")
			e.ArrStart()
			for _, elem := range s.IncludeText {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NumResults.Set {
			e.FieldStart("numResults")
			s.NumResults.Encode(e)
		}
	}
	{
		if s.StartCrawlDate.Set {
			e.FieldStart("startCrawlDate")
			s.StartCrawlDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.StartPublishedDate.Set {
			e.FieldStart("startPublishedDate")
			s.StartPublishedDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfFindSimilarReq = [12]string{
	0:  "url",
	1:  "contents",
	2:  "context",
	3:  "endCrawlDate",
	4:  "endPublishedDate",
	5:  "excludeDomains",
	6:  "excludeText",
	7:  "includeDomains",
	8:  "includeText",
	9:  "numResults",
	10: "startCrawlDate",
	11: "startPublishedDate",
}

// Decode decodes FindSimilarReq from json.
func (s *FindSimilarReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindSimilarReq to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "contents":
			if err := func() error {
				s.Contents.Reset()
				if err := s.Contents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "endCrawlDate":
			if err := func() error {
				s.EndCrawlDate.Reset()
				if err := s.EndCrawlDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endCrawlDate\"")
			}
		case "endPublishedDate":
			if err := func() error {
				s.EndPublishedDate.Reset()
				if err := s.EndPublishedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endPublishedDate\"")
			}
		case "excludeDomains":
			if err := func() error {
				s.ExcludeDomains = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExcludeDomains = append(s.ExcludeDomains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludeDomains\"")
			}
		case "excludeText":
			if err := func() error {
				s.ExcludeText = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExcludeText = append(s.ExcludeText, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludeText\"")
			}
		case "includeDomains":
			if err := func() error {
				s.IncludeDomains = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IncludeDomains = append(s.IncludeDomains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeDomains\"")
			}
		case "includeText":
			if err := func() error {
				s.IncludeText = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IncludeText = append(s.IncludeText, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeText\"")
			}
		case "numResults":
			if err := func() error {
				s.NumResults.Reset()
				if err := s.NumResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numResults\"")
			}
		case "startCrawlDate":
			if err := func() error {
				s.StartCrawlDate.Reset()
				if err := s.StartCrawlDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startCrawlDate\"")
			}
		case "startPublishedDate":
			if err := func() error {
				s.StartPublishedDate.Reset()
				if err := s.StartPublishedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startPublishedDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindSimilarReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFindSimilarReq) {
					name = jsonFieldsNameOfFindSimilarReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindSimilarReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindSimilarReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FindSimilarReqContext as json.
func (s FindSimilarReqContext) Encode(e *jx.Encoder) {
	switch s.Type {
	case BoolFindSimilarReqContext:
		e.Bool(s.Bool)
	case FindSimilarReqContext1FindSimilarReqContext:
		s.FindSimilarReqContext1.Encode(e)
	}
}

// Decode decodes FindSimilarReqContext from json.
func (s *FindSimilarReqContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindSimilarReqContext to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolFindSimilarReqContext
	case jx.Object:
		if err := s.FindSimilarReqContext1.Decode(d); err != nil {
			return err
		}
		s.Type = FindSimilarReqContext1FindSimilarReqContext
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FindSimilarReqContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindSimilarReqContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindSimilarReqContext1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindSimilarReqContext1) encodeFields(e *jx.Encoder) {
	{
		if s.MaxCharacters.Set {
			e.FieldStart("maxCharacters")
			s.MaxCharacters.Encode(e)
		}
	}
}

var jsonFieldsNameOfFindSimilarReqContext1 = [1]string{
	0: "maxCharacters",
}

// Decode decodes FindSimilarReqContext1 from json.
func (s *FindSimilarReqContext1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindSimilarReqContext1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxCharacters":
			if err := func() error {
				s.MaxCharacters.Reset()
				if err := s.MaxCharacters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxCharacters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindSimilarReqContext1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindSimilarReqContext1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindSimilarReqContext1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindSimilarResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindSimilarResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.CostDollars.Set {
			e.FieldStart("costDollars")
			s.CostDollars.Encode(e)
		}
	}
	{
		if s.RequestId.Set {
			e.FieldStart("requestId")
			s.RequestId.Encode(e)
		}
	}
	{
		if s.Results != nil {
			e.FieldStart("results")
			e.ArrStart()
			for _, elem := range s.Results {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfFindSimilarResponse = [4]string{
	0: "context",
	1: "costDollars",
	2: "requestId",
	3: "results",
}

// Decode decodes FindSimilarResponse from json.
func (s *FindSimilarResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindSimilarResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "costDollars":
			if err := func() error {
				s.CostDollars.Reset()
				if err := s.CostDollars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"costDollars\"")
			}
		case "requestId":
			if err := func() error {
				s.RequestId.Reset()
				if err := s.RequestId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestId\"")
			}
		case "results":
			if err := func() error {
				s.Results = make([]ResultWithContent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResultWithContent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindSimilarResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindSimilarResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindSimilarResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetContentsReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetContentsReq) encodeFields(e *jx.Encoder) {
	{
		if s.Ids != nil {
			e.FieldStart("ids")
			e.ArrStart()
			for _, elem := range s.Ids {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("urls")
		e.ArrStart()
		for _, elem := range s.Urls {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.Extras.Set {
			e.FieldStart("extras")
			s.Extras.Encode(e)
		}
	}
	{
		if s.Highlights.Set {
			e.FieldStart("highlights")
			s.Highlights.Encode(e)
		}
	}
	{
		if s.Livecrawl.Set {
			e.FieldStart("livecrawl")
			s.Livecrawl.Encode(e)
		}
	}
	{
		if s.LivecrawlTimeout.Set {
			e.FieldStart("livecrawlTimeout")
			s.LivecrawlTimeout.Encode(e)
		}
	}
	{
		if s.SubpageTarget.Set {
			e.FieldStart("subpageTarget")
			s.SubpageTarget.Encode(e)
		}
	}
	{
		if s.Subpages.Set {
			e.FieldStart("subpages")
			s.Subpages.Encode(e)
		}
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetContentsReq = [11]string{
	0:  "ids",
	1:  "urls",
	2:  "context",
	3:  "extras",
	4:  "highlights",
	5:  "livecrawl",
	6:  "livecrawlTimeout",
	7:  "subpageTarget",
	8:  "subpages",
	9:  "summary",
	10: "text",
}

// Decode decodes GetContentsReq from json.
func (s *GetContentsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentsReq to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ids":
			if err := func() error {
				s.Ids = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Ids = append(s.Ids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ids\"")
			}
		case "urls":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Urls = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Urls = append(s.Urls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"urls\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "extras":
			if err := func() error {
				s.Extras.Reset()
				if err := s.Extras.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extras\"")
			}
		case "highlights":
			if err := func() error {
				s.Highlights.Reset()
				if err := s.Highlights.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlights\"")
			}
		case "livecrawl":
			if err := func() error {
				s.Livecrawl.Reset()
				if err := s.Livecrawl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"livecrawl\"")
			}
		case "livecrawlTimeout":
			if err := func() error {
				s.LivecrawlTimeout.Reset()
				if err := s.LivecrawlTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"livecrawlTimeout\"")
			}
		case "subpageTarget":
			if err := func() error {
				s.SubpageTarget.Reset()
				if err := s.SubpageTarget.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subpageTarget\"")
			}
		case "subpages":
			if err := func() error {
				s.Subpages.Reset()
				if err := s.Subpages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subpages\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetContentsReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000010,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetContentsReq) {
					name = jsonFieldsNameOfGetContentsReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetContentsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetContentsReqContext as json.
func (s GetContentsReqContext) Encode(e *jx.Encoder) {
	switch s.Type {
	case BoolGetContentsReqContext:
		e.Bool(s.Bool)
	case GetContentsReqContext1GetContentsReqContext:
		s.GetContentsReqContext1.Encode(e)
	}
}

// Decode decodes GetContentsReqContext from json.
func (s *GetContentsReqContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentsReqContext to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolGetContentsReqContext
	case jx.Object:
		if err := s.GetContentsReqContext1.Decode(d); err != nil {
			return err
		}
		s.Type = GetContentsReqContext1GetContentsReqContext
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetContentsReqContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentsReqContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetContentsReqContext1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetContentsReqContext1) encodeFields(e *jx.Encoder) {
	{
		if s.MaxCharacters.Set {
			e.FieldStart("maxCharacters")
			s.MaxCharacters.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetContentsReqContext1 = [1]string{
	0: "maxCharacters",
}

// Decode decodes GetContentsReqContext1 from json.
func (s *GetContentsReqContext1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentsReqContext1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxCharacters":
			if err := func() error {
				s.MaxCharacters.Reset()
				if err := s.MaxCharacters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxCharacters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetContentsReqContext1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetContentsReqContext1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentsReqContext1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetContentsReqExtras) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetContentsReqExtras) encodeFields(e *jx.Encoder) {
	{
		if s.ImageLinks.Set {
			e.FieldStart("imageLinks")
			s.ImageLinks.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetContentsReqExtras = [2]string{
	0: "imageLinks",
	1: "links",
}

// Decode decodes GetContentsReqExtras from json.
func (s *GetContentsReqExtras) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentsReqExtras to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "imageLinks":
			if err := func() error {
				s.ImageLinks.Reset()
				if err := s.ImageLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageLinks\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetContentsReqExtras")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetContentsReqExtras) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentsReqExtras) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetContentsReqHighlights) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetContentsReqHighlights) encodeFields(e *jx.Encoder) {
	{
		if s.HighlightsPerUrl.Set {
			e.FieldStart("highlightsPerUrl")
			s.HighlightsPerUrl.Encode(e)
		}
	}
	{
		if s.NumSentences.Set {
			e.FieldStart("numSentences")
			s.NumSentences.Encode(e)
		}
	}
	{
		if s.Query.Set {
			e.FieldStart("query")
			s.Query.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetContentsReqHighlights = [3]string{
	0: "highlightsPerUrl",
	1: "numSentences",
	2: "query",
}

// Decode decodes GetContentsReqHighlights from json.
func (s *GetContentsReqHighlights) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentsReqHighlights to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "highlightsPerUrl":
			if err := func() error {
				s.HighlightsPerUrl.Reset()
				if err := s.HighlightsPerUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlightsPerUrl\"")
			}
		case "numSentences":
			if err := func() error {
				s.NumSentences.Reset()
				if err := s.NumSentences.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numSentences\"")
			}
		case "query":
			if err := func() error {
				s.Query.Reset()
				if err := s.Query.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetContentsReqHighlights")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetContentsReqHighlights) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentsReqHighlights) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetContentsReqLivecrawl as json.
func (s GetContentsReqLivecrawl) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetContentsReqLivecrawl from json.
func (s *GetContentsReqLivecrawl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentsReqLivecrawl to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetContentsReqLivecrawl(v) {
	case GetContentsReqLivecrawlNever:
		*s = GetContentsReqLivecrawlNever
	case GetContentsReqLivecrawlFallback:
		*s = GetContentsReqLivecrawlFallback
	case GetContentsReqLivecrawlAlways:
		*s = GetContentsReqLivecrawlAlways
	case GetContentsReqLivecrawlPreferred:
		*s = GetContentsReqLivecrawlPreferred
	default:
		*s = GetContentsReqLivecrawl(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetContentsReqLivecrawl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentsReqLivecrawl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetContentsReqSubpageTarget as json.
func (s GetContentsReqSubpageTarget) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringGetContentsReqSubpageTarget:
		e.Str(s.String)
	case StringArrayGetContentsReqSubpageTarget:
		e.ArrStart()
		for _, elem := range s.StringArray {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes GetContentsReqSubpageTarget from json.
func (s *GetContentsReqSubpageTarget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentsReqSubpageTarget to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.StringArray = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			s.StringArray = append(s.StringArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = StringArrayGetContentsReqSubpageTarget
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringGetContentsReqSubpageTarget
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetContentsReqSubpageTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentsReqSubpageTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetContentsReqSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetContentsReqSummary) encodeFields(e *jx.Encoder) {
	{
		if s.Query.Set {
			e.FieldStart("query")
			s.Query.Encode(e)
		}
	}
	{
		if s.Schema != nil {
			e.FieldStart("schema")
			s.Schema.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetContentsReqSummary = [2]string{
	0: "query",
	1: "schema",
}

// Decode decodes GetContentsReqSummary from json.
func (s *GetContentsReqSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentsReqSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "query":
			if err := func() error {
				s.Query.Reset()
				if err := s.Query.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "schema":
			if err := func() error {
				s.Schema = nil
				var elem GetContentsReqSummarySchema
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Schema = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetContentsReqSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetContentsReqSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentsReqSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetContentsReqSummarySchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetContentsReqSummarySchema) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetContentsReqSummarySchema = [0]string{}

// Decode decodes GetContentsReqSummarySchema from json.
func (s *GetContentsReqSummarySchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentsReqSummarySchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetContentsReqSummarySchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetContentsReqSummarySchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentsReqSummarySchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetContentsReqText as json.
func (s GetContentsReqText) Encode(e *jx.Encoder) {
	switch s.Type {
	case BoolGetContentsReqText:
		e.Bool(s.Bool)
	case GetContentsReqText1GetContentsReqText:
		s.GetContentsReqText1.Encode(e)
	}
}

// Decode decodes GetContentsReqText from json.
func (s *GetContentsReqText) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentsReqText to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolGetContentsReqText
	case jx.Object:
		if err := s.GetContentsReqText1.Decode(d); err != nil {
			return err
		}
		s.Type = GetContentsReqText1GetContentsReqText
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetContentsReqText) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentsReqText) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetContentsReqText1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetContentsReqText1) encodeFields(e *jx.Encoder) {
	{
		if s.IncludeHtmlTags.Set {
			e.FieldStart("includeHtmlTags")
			s.IncludeHtmlTags.Encode(e)
		}
	}
	{
		if s.MaxCharacters.Set {
			e.FieldStart("maxCharacters")
			s.MaxCharacters.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetContentsReqText1 = [2]string{
	0: "includeHtmlTags",
	1: "maxCharacters",
}

// Decode decodes GetContentsReqText1 from json.
func (s *GetContentsReqText1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetContentsReqText1 to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "includeHtmlTags":
			if err := func() error {
				s.IncludeHtmlTags.Reset()
				if err := s.IncludeHtmlTags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeHtmlTags\"")
			}
		case "maxCharacters":
			if err := func() error {
				s.MaxCharacters.Reset()
				if err := s.MaxCharacters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxCharacters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetContentsReqText1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetContentsReqText1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetContentsReqText1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsRequest as json.
func (o OptContentsRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContentsRequest from json.
func (o *OptContentsRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContentsRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContentsRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContentsRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsRequestContext as json.
func (o OptContentsRequestContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContentsRequestContext from json.
func (o *OptContentsRequestContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContentsRequestContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContentsRequestContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContentsRequestContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsRequestExtras as json.
func (o OptContentsRequestExtras) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContentsRequestExtras from json.
func (o *OptContentsRequestExtras) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContentsRequestExtras to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContentsRequestExtras) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContentsRequestExtras) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsRequestHighlights as json.
func (o OptContentsRequestHighlights) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContentsRequestHighlights from json.
func (o *OptContentsRequestHighlights) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContentsRequestHighlights to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContentsRequestHighlights) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContentsRequestHighlights) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsRequestLivecrawl as json.
func (o OptContentsRequestLivecrawl) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ContentsRequestLivecrawl from json.
func (o *OptContentsRequestLivecrawl) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContentsRequestLivecrawl to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContentsRequestLivecrawl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContentsRequestLivecrawl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsRequestSubpageTarget as json.
func (o OptContentsRequestSubpageTarget) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContentsRequestSubpageTarget from json.
func (o *OptContentsRequestSubpageTarget) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContentsRequestSubpageTarget to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContentsRequestSubpageTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContentsRequestSubpageTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsRequestSummary as json.
func (o OptContentsRequestSummary) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContentsRequestSummary from json.
func (o *OptContentsRequestSummary) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContentsRequestSummary to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContentsRequestSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContentsRequestSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsRequestText as json.
func (o OptContentsRequestText) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContentsRequestText from json.
func (o *OptContentsRequestText) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContentsRequestText to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContentsRequestText) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContentsRequestText) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsResponseStatusesItemErrorTag as json.
func (o OptContentsResponseStatusesItemErrorTag) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ContentsResponseStatusesItemErrorTag from json.
func (o *OptContentsResponseStatusesItemErrorTag) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContentsResponseStatusesItemErrorTag to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContentsResponseStatusesItemErrorTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContentsResponseStatusesItemErrorTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsResponseStatusesItemStatus as json.
func (o OptContentsResponseStatusesItemStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ContentsResponseStatusesItemStatus from json.
func (o *OptContentsResponseStatusesItemStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContentsResponseStatusesItemStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContentsResponseStatusesItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContentsResponseStatusesItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CostDollars as json.
func (o OptCostDollars) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CostDollars from json.
func (o *OptCostDollars) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCostDollars to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCostDollars) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCostDollars) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CostDollarsBreakDownItemBreakdown as json.
func (o OptCostDollarsBreakDownItemBreakdown) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CostDollarsBreakDownItemBreakdown from json.
func (o *OptCostDollarsBreakDownItemBreakdown) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCostDollarsBreakDownItemBreakdown to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCostDollarsBreakDownItemBreakdown) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCostDollarsBreakDownItemBreakdown) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CostDollarsPerPagePrices as json.
func (o OptCostDollarsPerPagePrices) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CostDollarsPerPagePrices from json.
func (o *OptCostDollarsPerPagePrices) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCostDollarsPerPagePrices to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCostDollarsPerPagePrices) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCostDollarsPerPagePrices) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CostDollarsPerRequestPrices as json.
func (o OptCostDollarsPerRequestPrices) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CostDollarsPerRequestPrices from json.
func (o *OptCostDollarsPerRequestPrices) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCostDollarsPerRequestPrices to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCostDollarsPerRequestPrices) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCostDollarsPerRequestPrices) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes FindSimilarReqContext as json.
func (o OptFindSimilarReqContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FindSimilarReqContext from json.
func (o *OptFindSimilarReqContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFindSimilarReqContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFindSimilarReqContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFindSimilarReqContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetContentsReqContext as json.
func (o OptGetContentsReqContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetContentsReqContext from json.
func (o *OptGetContentsReqContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetContentsReqContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetContentsReqContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetContentsReqContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetContentsReqExtras as json.
func (o OptGetContentsReqExtras) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetContentsReqExtras from json.
func (o *OptGetContentsReqExtras) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetContentsReqExtras to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetContentsReqExtras) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetContentsReqExtras) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetContentsReqHighlights as json.
func (o OptGetContentsReqHighlights) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetContentsReqHighlights from json.
func (o *OptGetContentsReqHighlights) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetContentsReqHighlights to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetContentsReqHighlights) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetContentsReqHighlights) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetContentsReqLivecrawl as json.
func (o OptGetContentsReqLivecrawl) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetContentsReqLivecrawl from json.
func (o *OptGetContentsReqLivecrawl) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetContentsReqLivecrawl to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetContentsReqLivecrawl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetContentsReqLivecrawl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetContentsReqSubpageTarget as json.
func (o OptGetContentsReqSubpageTarget) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetContentsReqSubpageTarget from json.
func (o *OptGetContentsReqSubpageTarget) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetContentsReqSubpageTarget to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetContentsReqSubpageTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetContentsReqSubpageTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetContentsReqSummary as json.
func (o OptGetContentsReqSummary) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetContentsReqSummary from json.
func (o *OptGetContentsReqSummary) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetContentsReqSummary to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetContentsReqSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetContentsReqSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetContentsReqText as json.
func (o OptGetContentsReqText) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetContentsReqText from json.
func (o *OptGetContentsReqText) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetContentsReqText to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetContentsReqText) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetContentsReqText) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContentsResponseStatusesItemError as json.
func (o OptNilContentsResponseStatusesItemError) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContentsResponseStatusesItemError from json.
func (o *OptNilContentsResponseStatusesItemError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilContentsResponseStatusesItemError to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ContentsResponseStatusesItemError
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilContentsResponseStatusesItemError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilContentsResponseStatusesItemError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptNilFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptNilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResultWithContentExtras as json.
func (o OptResultWithContentExtras) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResultWithContentExtras from json.
func (o *OptResultWithContentExtras) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResultWithContentExtras to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResultWithContentExtras) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResultWithContentExtras) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchReqCategory as json.
func (o OptSearchReqCategory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SearchReqCategory from json.
func (o *OptSearchReqCategory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchReqCategory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchReqCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchReqCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchReqContext as json.
func (o OptSearchReqContext) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SearchReqContext from json.
func (o *OptSearchReqContext) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchReqContext to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchReqContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchReqContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchReqType as json.
func (o OptSearchReqType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SearchReqType from json.
func (o *OptSearchReqType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchReqType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchReqType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchReqType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchResponseSearchType as json.
func (o OptSearchResponseSearchType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SearchResponseSearchType from json.
func (o *OptSearchResponseSearchType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSearchResponseSearchType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSearchResponseSearchType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSearchResponseSearchType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultWithContent) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultWithContent) encodeFields(e *jx.Encoder) {
	{
		if s.Author.Set {
			e.FieldStart("author")
			s.Author.Encode(e)
		}
	}
	{
		if s.Favicon.Set {
			e.FieldStart("favicon")
			s.Favicon.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Image.Set {
			e.FieldStart("image")
			s.Image.Encode(e)
		}
	}
	{
		if s.PublishedDate.Set {
			e.FieldStart("publishedDate")
			s.PublishedDate.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Extras.Set {
			e.FieldStart("extras")
			s.Extras.Encode(e)
		}
	}
	{
		if s.HighlightScores != nil {
			e.FieldStart("highlightScores")
			e.ArrStart()
			for _, elem := range s.HighlightScores {
				e.Float32(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Highlights != nil {
			e.FieldStart("highlights")
			e.ArrStart()
			for _, elem := range s.Highlights {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Subpages != nil {
			e.FieldStart("subpages")
			e.ArrStart()
			for _, elem := range s.Subpages {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		if s.Text.Set {
			e.FieldStart("text")
			s.Text.Encode(e)
		}
	}
}

var jsonFieldsNameOfResultWithContent = [14]string{
	0:  "author",
	1:  "favicon",
	2:  "id",
	3:  "image",
	4:  "publishedDate",
	5:  "score",
	6:  "title",
	7:  "url",
	8:  "extras",
	9:  "highlightScores",
	10: "highlights",
	11: "subpages",
	12: "summary",
	13: "text",
}

// Decode decodes ResultWithContent from json.
func (s *ResultWithContent) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultWithContent to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "author":
			if err := func() error {
				s.Author.Reset()
				if err := s.Author.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "favicon":
			if err := func() error {
				s.Favicon.Reset()
				if err := s.Favicon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"favicon\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "image":
			if err := func() error {
				s.Image.Reset()
				if err := s.Image.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image\"")
			}
		case "publishedDate":
			if err := func() error {
				s.PublishedDate.Reset()
				if err := s.PublishedDate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publishedDate\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "extras":
			if err := func() error {
				s.Extras.Reset()
				if err := s.Extras.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extras\"")
			}
		case "highlightScores":
			if err := func() error {
				s.HighlightScores = make([]float32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem float32
					v, err := d.Float32()
					elem = float32(v)
					if err != nil {
						return err
					}
					s.HighlightScores = append(s.HighlightScores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlightScores\"")
			}
		case "highlights":
			if err := func() error {
				s.Highlights = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Highlights = append(s.Highlights, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"highlights\"")
			}
		case "subpages":
			if err := func() error {
				s.Subpages = make([]ResultWithContent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResultWithContent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subpages = append(s.Subpages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subpages\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "text":
			if err := func() error {
				s.Text.Reset()
				if err := s.Text.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultWithContent")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultWithContent) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultWithContent) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResultWithContentExtras) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResultWithContentExtras) encodeFields(e *jx.Encoder) {
	{
		if s.Links != nil {
			e.FieldStart("links")
			e.ArrStart()
			for _, elem := range s.Links {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfResultWithContentExtras = [1]string{
	0: "links",
}

// Decode decodes ResultWithContentExtras from json.
func (s *ResultWithContentExtras) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResultWithContentExtras to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "links":
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResultWithContentExtras")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResultWithContentExtras) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResultWithContentExtras) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchReq) encodeFields(e *jx.Encoder) {
	{
		if s.AdditionalQueries != nil {
			e.FieldStart("additionalQueries")
			e.ArrStart()
			for _, elem := range s.AdditionalQueries {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		e.FieldStart("query")
		e.Str(s.Query)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.UserLocation.Set {
			e.FieldStart("userLocation")
			s.UserLocation.Encode(e)
		}
	}
	{
		if s.Contents.Set {
			e.FieldStart("contents")
			s.Contents.Encode(e)
		}
	}
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.EndCrawlDate.Set {
			e.FieldStart("endCrawlDate")
			s.EndCrawlDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.EndPublishedDate.Set {
			e.FieldStart("endPublishedDate")
			s.EndPublishedDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ExcludeDomains != nil {
			e.FieldStart("excludeDomains")
			e.ArrStart()
			for _, elem := range s.ExcludeDomains {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExcludeText != nil {
			e.FieldStart("excludeText")
			e.ArrStart()
			for _, elem := range s.ExcludeText {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IncludeDomains != nil {
			e.FieldStart("includeDomains")
			e.ArrStart()
			for _, elem := range s.IncludeDomains {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IncludeText != nil {
			e.FieldStart("includeText")
			e.ArrStart()
			for _, elem := range s.IncludeText {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NumResults.Set {
			e.FieldStart("numResults")
			s.NumResults.Encode(e)
		}
	}
	{
		if s.StartCrawlDate.Set {
			e.FieldStart("startCrawlDate")
			s.StartCrawlDate.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.StartPublishedDate.Set {
			e.FieldStart("startPublishedDate")
			s.StartPublishedDate.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfSearchReq = [16]string{
	0:  "additionalQueries",
	1:  "category",
	2:  "query",
	3:  "type",
	4:  "userLocation",
	5:  "contents",
	6:  "context",
	7:  "endCrawlDate",
	8:  "endPublishedDate",
	9:  "excludeDomains",
	10: "excludeText",
	11: "includeDomains",
	12: "includeText",
	13: "numResults",
	14: "startCrawlDate",
	15: "startPublishedDate",
}

// Decode decodes SearchReq from json.
func (s *SearchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchReq to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "additionalQueries":
			if err := func() error {
				s.AdditionalQueries = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AdditionalQueries = append(s.AdditionalQueries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalQueries\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "query":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Query = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "userLocation":
			if err := func() error {
				s.UserLocation.Reset()
				if err := s.UserLocation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userLocation\"")
			}
		case "contents":
			if err := func() error {
				s.Contents.Reset()
				if err := s.Contents.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contents\"")
			}
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "endCrawlDate":
			if err := func() error {
				s.EndCrawlDate.Reset()
				if err := s.EndCrawlDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endCrawlDate\"")
			}
		case "endPublishedDate":
			if err := func() error {
				s.EndPublishedDate.Reset()
				if err := s.EndPublishedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endPublishedDate\"")
			}
		case "excludeDomains":
			if err := func() error {
				s.ExcludeDomains = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExcludeDomains = append(s.ExcludeDomains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludeDomains\"")
			}
		case "excludeText":
			if err := func() error {
				s.ExcludeText = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExcludeText = append(s.ExcludeText, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"excludeText\"")
			}
		case "includeDomains":
			if err := func() error {
				s.IncludeDomains = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IncludeDomains = append(s.IncludeDomains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeDomains\"")
			}
		case "includeText":
			if err := func() error {
				s.IncludeText = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IncludeText = append(s.IncludeText, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"includeText\"")
			}
		case "numResults":
			if err := func() error {
				s.NumResults.Reset()
				if err := s.NumResults.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numResults\"")
			}
		case "startCrawlDate":
			if err := func() error {
				s.StartCrawlDate.Reset()
				if err := s.StartCrawlDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startCrawlDate\"")
			}
		case "startPublishedDate":
			if err := func() error {
				s.StartPublishedDate.Reset()
				if err := s.StartPublishedDate.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startPublishedDate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000100,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchReq) {
					name = jsonFieldsNameOfSearchReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchReqCategory as json.
func (s SearchReqCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchReqCategory from json.
func (s *SearchReqCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchReqCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchReqCategory(v) {
	case SearchReqCategoryCompany:
		*s = SearchReqCategoryCompany
	case SearchReqCategoryResearchPaper:
		*s = SearchReqCategoryResearchPaper
	case SearchReqCategoryNews:
		*s = SearchReqCategoryNews
	case SearchReqCategoryPdf:
		*s = SearchReqCategoryPdf
	case SearchReqCategoryGithub:
		*s = SearchReqCategoryGithub
	case SearchReqCategoryTweet:
		*s = SearchReqCategoryTweet
	case SearchReqCategoryPersonalSite:
		*s = SearchReqCategoryPersonalSite
	case SearchReqCategoryPeople:
		*s = SearchReqCategoryPeople
	case SearchReqCategoryFinancialReport:
		*s = SearchReqCategoryFinancialReport
	default:
		*s = SearchReqCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SearchReqCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchReqCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchReqContext as json.
func (s SearchReqContext) Encode(e *jx.Encoder) {
	switch s.Type {
	case BoolSearchReqContext:
		e.Bool(s.Bool)
	case SearchReqContext1SearchReqContext:
		s.SearchReqContext1.Encode(e)
	}
}

// Decode decodes SearchReqContext from json.
func (s *SearchReqContext) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchReqContext to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolSearchReqContext
	case jx.Object:
		if err := s.SearchReqContext1.Decode(d); err != nil {
			return err
		}
		s.Type = SearchReqContext1SearchReqContext
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SearchReqContext) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchReqContext) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchReqContext1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchReqContext1) encodeFields(e *jx.Encoder) {
	{
		if s.MaxCharacters.Set {
			e.FieldStart("maxCharacters")
			s.MaxCharacters.Encode(e)
		}
	}
}

var jsonFieldsNameOfSearchReqContext1 = [1]string{
	0: "maxCharacters",
}

// Decode decodes SearchReqContext1 from json.
func (s *SearchReqContext1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchReqContext1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxCharacters":
			if err := func() error {
				s.MaxCharacters.Reset()
				if err := s.MaxCharacters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxCharacters\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchReqContext1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchReqContext1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchReqContext1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchReqType as json.
func (s SearchReqType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchReqType from json.
func (s *SearchReqType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchReqType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchReqType(v) {
	case SearchReqTypeNeural:
		*s = SearchReqTypeNeural
	case SearchReqTypeFast:
		*s = SearchReqTypeFast
	case SearchReqTypeAuto:
		*s = SearchReqTypeAuto
	case SearchReqTypeDeep:
		*s = SearchReqTypeDeep
	default:
		*s = SearchReqType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SearchReqType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchReqType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Context.Set {
			e.FieldStart("context")
			s.Context.Encode(e)
		}
	}
	{
		if s.CostDollars.Set {
			e.FieldStart("costDollars")
			s.CostDollars.Encode(e)
		}
	}
	{
		if s.RequestId.Set {
			e.FieldStart("requestId")
			s.RequestId.Encode(e)
		}
	}
	{
		if s.Results != nil {
			e.FieldStart("results")
			e.ArrStart()
			for _, elem := range s.Results {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SearchType.Set {
			e.FieldStart("searchType")
			s.SearchType.Encode(e)
		}
	}
}

var jsonFieldsNameOfSearchResponse = [5]string{
	0: "context",
	1: "costDollars",
	2: "requestId",
	3: "results",
	4: "searchType",
}

// Decode decodes SearchResponse from json.
func (s *SearchResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "context":
			if err := func() error {
				s.Context.Reset()
				if err := s.Context.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context\"")
			}
		case "costDollars":
			if err := func() error {
				s.CostDollars.Reset()
				if err := s.CostDollars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"costDollars\"")
			}
		case "requestId":
			if err := func() error {
				s.RequestId.Reset()
				if err := s.RequestId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestId\"")
			}
		case "results":
			if err := func() error {
				s.Results = make([]ResultWithContent, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResultWithContent
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		case "searchType":
			if err := func() error {
				s.SearchType.Reset()
				if err := s.SearchType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"searchType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SearchResponseSearchType as json.
func (s SearchResponseSearchType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SearchResponseSearchType from json.
func (s *SearchResponseSearchType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResponseSearchType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SearchResponseSearchType(v) {
	case SearchResponseSearchTypeNeural:
		*s = SearchResponseSearchTypeNeural
	case SearchResponseSearchTypeDeep:
		*s = SearchResponseSearchTypeDeep
	default:
		*s = SearchResponseSearchType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SearchResponseSearchType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResponseSearchType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
